# Хайпанём немножечко!
# 
# Блокчейн (blockchain) переводится как «цепочка блоков».
# Это способ хранения данных, защищённый от подделки.
# Он лежит, например, в основе криптовалюты биткоин.
# Блокчейн — это действительно последовательность блоков, а в каждом блоке находится некоторая полезная информация.
# Так последовательность биткоина — список транзакций за определённый период времени:
# кто, кому, когда и сколько денег передал.
# Этот список снабжён случайным числом и некоторыми служебными данными,
# в том числе хэшем — числом, которое по определённой формуле зависит от остальной части блока и хэша предыдущего блока.
# Хэш должен быть меньше определённого числа.
# При этом формула, по которой вычисляется хэш, устроена так,
# что невозможно получить достаточно маленький хэш иначе,
# чем перебирая различные значения случайного числа.
# Поэтому если злоумышленник решит подделать блокчейн — например,
# вставить в его середину блок с записью о том,
# что все люди передали ему все свои деньги, — то столкнётся с проблемой.
# Ему придётся подобрать новое случайное число не только в поддельном блоке,
# но и во всех последующих, ведь хэш каждого следующего блока зависит от хэша предыдущего.
# Это требует невероятно больших вычислительных мощностей,
# поэтому блокчейн в целом защищён от подобных атак.
# Напишите программу, которая проводит проверку правильности хэшей в модельном блокчейне с простой хэш-функцией.
# Блок b(n) с номером n включает полезную информацию m(n),
# представленную натуральным числом,
# r(n) — случайное число от 0 до 255 и 
# h(n) — хэш (целое число от 0 до 255).
# У каждого блока хэш вычисляется по формуле h(n) = 37 × (m(n) + r(n) + h(n−1)) (по модулю 256),
# при вычислении хэша начального блока h(0) вместо хэша предыдущего блока берётся ноль.
# При этом каждый блок представлен одним числом b(n) = h(n) + r(n) × 256 + m(n) × 256^2.
# Также требуется, чтобы хэш h(n) был меньше 100.
# 
# Формат ввода
# На первой строке вводится натуральное число N — количество блоков.
# Далее следуют N чисел b(n), каждое на отдельной строке.
# 
# Формат вывода
# Следует вывести номер первого блока, у которого неправильный хэш
# (не меньше 100 или не совпадает с вычисленным по указанной в условии формуле),
# или -1, если все хэши в блокчейне правильные.
# Нумерация блоков идёт с нуля, так что они имеют номера от 0 до N-1.

last_h = 0

for i in range(int(input())):
    block = int(input())

    now_h = block % 256 
    r = (block // 256) % 256 
    m = block // 256 ** 2 
    calc_h = (37 * (m + r + last_h)) % 256
    print(last_h, now_h, r, m, calc_h, sep='\n')

    if calc_h != now_h or calc_h > 100:
        print(i)
        break

    last_h = calc_h
else:
    print(-1)

# То ли я тупой, то ли объяснение нифига непонятное...
# Нашел данное решение в интернете и только тогда +- понял, что от нас хотят.
# Мне кажется, что задачка сложновата для человека, который только начал учить Python.
# Ну либо надо очень хорошо с математикой ладить, у меня с этим беда...
# Настолько беда, что объяснение от ChatGPT мне не сильно помогает.
# Я всё равно не понимаю, почему некоторые вещи вычисляются так, а не иначе.
# 
# Объяснение от ChatGPT:
# Есть блоки b(n), где n - номер блока. Каждый блок содержит:
# 
# m(n) - натуральное число,
# r(n) - случайное число от 0 до 255,
# h(n) - хэш (целое число от 0 до 255).
# Хэш h(n) вычисляется по формуле: h(n) = 37 × (m(n) + r(n) + h(n−1)) (по модулю 256), где h(0) = 0.
# 
# Каждый блок представлен одним числом b(n) = h(n) + r(n) × 256 + m(n) × 256^2.
# 
# Требуется, чтобы хэш h(n) был меньше 100.
# 
# Необходимо найти номер первого блока с неправильным хэшем и вывести его номер, или -1, если все хэши правильные.
# 
# Теперь давайте сопоставим условия с представленным кодом:
# 
# last_h в коде соответствует h(n−1) в условии.
# block соответствует b(n) в условии.
# now_h соответствует h(n) в условии.
# r и m в коде вычисляются так, чтобы соблюсти формулу для вычисления хэша.
# 
# Код выполняет следующее:
# Инициализирует переменную last_h с нулевым значением, что соответствует h(0).
# Запрашивает у пользователя ввод числа n, которое представляет собой количество блоков в цепочке.
# Затем цикл for выполняется n раз, где каждая итерация считывает ввод пользователя в переменную block. Внутри цикла происходят следующие действия:
# now_h вычисляет остаток от деления block на 256. Это текущее значение хэша, соответствующее h(n) в условии.
# r вычисляет значение, полученное делением block на 256, а затем взятием остатка от этого деления по модулю 256, что соответствует r(n) в условии.
# m вычисляет значение, полученное делением block на 256 в квадрате, что соответствует m(n) в условии.
# calc_h вычисляет новое значение хеша (calc_h) на основе формулы, аналогичной формуле из условия.
# Затем происходит проверка условия calc_h != now_h or calc_h > 100. Если условие выполняется, программа выводит номер итерации i и завершает выполнение цикла с помощью break.
# Если условие в пункте 4 не выполняется ни разу во всех итерациях цикла for, то выводится -1, что означает, что ни одно из чисел block не соответствует условиям в условии задачи.